\chapter{Algoritmi Steganografici Implementati}

\section{LSB - Least Significant Bit}

\subsection{Principio di Funzionamento}

L'algoritmo LSB (Least Significant Bit) è uno dei metodi steganografici più diffusi grazie 
alla sua semplicità e alta capacità~\cite{cheddad2010lsb}. Il principio si basa sull'osservazione che modificare 
i bit meno significativi dei valori dei pixel produce cambiamenti impercettibili all'occhio 
umano.

In un'immagine RGB a 8 bit per canale, ogni pixel ha valori tra 0 e 255. Modificare l'ultimo 
bit (LSB) cambia il valore del pixel al massimo di ±1, una differenza invisibile.

\textbf{Esempio:}
\begin{itemize}
    \item Pixel originale: $11010110_2 = 214_{10}$
    \item Bit da nascondere: $1$
    \item Pixel modificato: $11010111_2 = 215_{10}$
\end{itemize}

\subsection{Implementazione}

L'implementazione nel progetto utilizza un approccio robusto con header strutturato:

\begin{lstlisting}[caption={Struttura del payload LSB}]
magic_header = "1010101011110000"
msg_length = format(len(message), "032b")
checksum = format(xor_checksum, "016b")
msg_binary = binary_convert(message)
terminator = "1111000011110000"

full_payload = magic_header + msg_length + checksum + msg_binary + terminator
\end{lstlisting}

Il processo di embedding scorre i pixel dell'immagine modificando l'LSB di ogni componente 
RGB:

\begin{lstlisting}[caption={Nascondimento LSB}]
for i in range(img.width):
    for j in range(img.height):
        for z in range(3):  # R, G, B
            if msg_list:
                bit = msg_list.pop(0)
                pixel = mat[i, j]
                color = int(pixel[z])
                color = set_last_bit(color, bit)
                mat = set_color_component(mat, i, j, color, z)
\end{lstlisting}

\subsection{Capacità e Prestazioni}

Per un'immagine di dimensione $W \times H$ pixel:
\begin{itemize}
    \item \textbf{Capacità teorica massima}: $W \times H \times 3$ bit (3 bit per pixel RGB)
    \item \textbf{Overhead header}: 80 bit fissi (magic + length + checksum + terminator)
    \item \textbf{Capacità effettiva}: $W \times H \times 3 - 80$ bit
\end{itemize}

\textbf{Esempio pratico:}
\begin{itemize}
    \item Immagine 800×600: 1,440,000 bit teorici = 180 KB
    \item Capacità effettiva: 179.99 KB
    \item Percentuale uso tipico: 0.1-5\% per messaggi normali
\end{itemize}

\subsection{Vantaggi e Limitazioni}

L'algoritmo LSB si distingue per la sua semplicità implementativa e l'elevata capacità di
embedding, offrendo tipicamente PSNR superiori a 50 dB che garantiscono modifiche del tutto
impercettibili all'occhio umano. Tuttavia, questa efficienza ha un costo in termini di robustezza:
qualsiasi compressione JPEG o manipolazione dell'immagine distrugge i bit meno significativi,
rendendo impossibile il recupero dei dati. Inoltre, l'approccio è vulnerabile ad analisi
statistiche che possono rilevare la presenza di dati nascosti attraverso anomalie nella
distribuzione dei valori dei pixel.

\section{DWT - Discrete Wavelet Transform}

\subsection{Principio di Funzionamento}

La DWT (Discrete Wavelet Transform) è una trasformazione matematica che decompone un segnale 
(o immagine) in coefficienti che rappresentano informazioni a diverse scale e posizioni. 
A differenza di LSB che opera nel dominio spaziale, DWT lavora nel dominio della frequenza.

La trasformata wavelet 2D decompone un'immagine in quattro sub-bande:
\begin{itemize}
    \item \textbf{cA (Approximation)}: Coefficienti di approssimazione - contiene informazioni 
          a bassa frequenza
    \item \textbf{cH (Horizontal)}: Dettagli orizzontali - bordi verticali
    \item \textbf{cV (Vertical)}: Dettagli verticali - bordi orizzontali  
    \item \textbf{cD (Diagonal)}: Dettagli diagonali - componenti ad alta frequenza
\end{itemize}

\subsection{Implementazione}

Il progetto utilizza la wavelet di Haar per la sua semplicità e efficienza~\cite{pywavelets2023}.
L'implementazione usa \texttt{pywt.dwt2} per decomposizione single-level, garantendo efficienza
e capacità prevedibile.

\begin{lstlisting}[caption={Decomposizione DWT}]
import pywt

# Applica DWT 2D single-level al canale dell'immagine
coeffs = pywt.dwt2(channel_data, 'haar')
cA, (cH, cV, cD) = coeffs

# Nasconde nei coefficienti orizzontali (cH)
cH_flat = cH.flatten()
\end{lstlisting}

\textbf{Header Robusto a 64-bit:}

Per evitare false positive detection nel rumore dei coefficienti DWT, il sistema usa un
magic header a 64-bit invece del tradizionale 16-bit:

\begin{lstlisting}[caption={Header DWT robusto}]
# Header 64-bit per robustezza
MAGIC_HEADER_64 = "1100100100001111010110010100110011010101010011110000101011001101"
SIZE_BITS = 32  # Dimensione payload in bit

# Struttura: [64-bit magic][32-bit size][payload]
full_payload = MAGIC_HEADER_64 + format(payload_size, "032b") + payload_bits
\end{lstlisting}

\textbf{Estrazione Two-Phase:}

L'estrazione avviene in due fasi sincronizzate per evitare lettura di rumore:

\begin{lstlisting}[caption={Estrazione two-phase DWT}]
# FASE 1: Estrae header + size (96 bit totali)
header_and_size = extract_bits_from_coefficients(96)
magic = header_and_size[:64]
payload_size = int(header_and_size[64:96], 2)

# Verifica header
if magic != MAGIC_HEADER_64:
    raise ValueError("Header non trovato")

# FASE 2: Estrae esattamente payload_size bit
payload = extract_bits_from_coefficients(payload_size)
\end{lstlisting}

Questo approccio garantisce che l'estrazione si fermi esattamente dopo il payload,
evitando di leggere coefficienti non modificati che causerebbero corruzione dei dati.

L'embedding avviene modificando i coefficienti in base al bit da nascondere:

\begin{lstlisting}[caption={Embedding DWT}]
# Modifica il coefficiente usando ALPHA
bit = int(payload_bit)
delta = ALPHA * 50  # Scala per robustezza

if bit == 1:
    cH_flat[i] += delta if cH_flat[i] > 0 else -delta
else:
    cH_flat[i] -= delta if cH_flat[i] > 0 else -delta
\end{lstlisting}

Il parametro \texttt{ALPHA} controlla la forza dell'embedding:
\begin{itemize}
    \item $\alpha = 0.05$: Qualità massima, capacità ridotta
    \item $\alpha = 0.1$: Bilanciato (default)
    \item $\alpha = 0.15$: Robustezza massima, più visibile
\end{itemize}

\subsection{Configurazioni Implementate}

Il sistema offre tre preset configurabili:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Preset} & \textbf{ALPHA} & \textbf{Bande} & \textbf{Canali} \\ \hline
Qualità Massima & 0.05 & cH & R \\ \hline
Bilanciato & 0.10 & cH & R \\ \hline
Capacità Massima & 0.15 & cH, cV, cD & R, G, B \\ \hline
\end{tabular}
\caption{Configurazioni preset DWT}
\end{table}

\subsection{Caratteristiche dell'Approccio}

Il principale punto di forza della DWT risiede nella sua robustezza: operando nel dominio
della frequenza, l'algoritmo resiste a compressioni JPEG, filtri e aggiunte di rumore che
distruggerebbero completamente i dati nascosti con LSB. Questa robustezza si paga con una
capacità di embedding ridotta e un costo computazionale superiore. Il PSNR tipicamente si
attesta tra 35 e 45 dB, comunque sufficiente per garantire modifiche visivamente accettabili.
La calibrazione del parametro ALPHA richiede un bilanciamento attento tra robustezza e
qualità visiva, rendendo i preset configurabili particolarmente utili per utenti meno esperti.

\section{PVD - Pixel Value Differencing}

\subsection{Principio di Funzionamento}

PVD (Pixel Value Differencing) è un algoritmo adattivo che sfrutta la differenza tra pixel 
adiacenti per nascondere dati. L'idea chiave è che modifiche maggiori sono meno percepibili 
in regioni con alti contrasti (bordi), mentre in regioni uniformi sono necessarie modifiche 
minori.

Il metodo divide l'immagine in coppie di pixel e calcola la loro differenza~\cite{wu2004pvd}:
$$d = |p_2 - p_1|$$

In base alla differenza, viene determinata la capacità di embedding usando range quantizzati.

\subsection{Range di Quantizzazione}

L'implementazione offre due profili di range:

\textbf{Profile Qualità (default):}
\begin{lstlisting}[caption={Range qualità PVD}]
RANGES_QUALITY = [
    (0, 7, 2),
    (8, 15, 3),
    (16, 31, 3),
    (32, 63, 4),
    (64, 127, 4),
]
\end{lstlisting}

\textbf{Profile Capacità:}
\begin{lstlisting}[caption={Range capacità PVD}]
RANGES_CAPACITY = [
    (0, 7, 3),
    (8, 15, 3),
    (16, 31, 4),
    (32, 63, 5),
    (64, 127, 6),
    (128, 255, 7),
]
\end{lstlisting}

\subsection{Algoritmo di Embedding}

\begin{lstlisting}[caption={PVD embedding in una coppia di pixel}]
def embed_in_pair(pixel1, pixel2, bits):
    diff = pixel2 - pixel1
    lower, upper, capacity = get_range_capacity(diff)
    
    decimal_value = int(bits[:capacity], 2)
    new_diff = lower + decimal_value
    new_diff = min(new_diff, upper)
    
    if diff < 0:
        new_diff = -new_diff
    
    m = abs(new_diff) - abs(diff)
    if diff % 2 == 0:
        new_pixel1 = pixel1 - m // 2
        new_pixel2 = pixel2 + m - m // 2
    else:
        new_pixel1 = pixel1 - (m + 1) // 2
        new_pixel2 = pixel2 + m - (m + 1) // 2
    
    return max(0, min(255, new_pixel1)), max(0, min(255, new_pixel2))
\end{lstlisting}

\subsection{Parametri Configurabili}

L'implementazione offre tre parametri principali. Il profilo di quantizzazione \texttt{RANGES}
determina la capacità di embedding per ogni livello di differenza tra pixel. Il fallback
utilizza l'ultimo range definito (\texttt{RANGES[-1]}) invece di un valore hardcoded,
garantendo compatibilità tra modalità QUALITY e CAPACITY.

La spaziatura \texttt{PAIR\_STEP} controlla la distanza tra coppie consecutive di pixel.
Con \texttt{PAIR\_STEP=1} si ottiene la massima capacità utilizzando tutti i pixel disponibili,
mentre valori superiori distribuiscono l'embedding su un'area più ampia riducendo la capacità.
I loop di attraversamento usano \texttt{range(0, w - PAIR\_STEP, 2*PAIR\_STEP)} per prevenire
accessi out-of-bounds quando si legge \texttt{pixel[x + PAIR\_STEP]}.

Il parametro \texttt{CHANNELS} specifica quali canali RGB utilizzare. Il calcolo di
\texttt{total\_bits} impiega \texttt{len(channels)} per determinare precisamente la capacità
disponibile indipendentemente dalla configurazione.

L'implementazione richiede particolare attenzione alla sincronizzazione tra le fasi di
embedding ed estrazione. Durante il processo di inserimento, l'indice deve essere incrementato
esattamente del numero di bit effettivamente inseriti, e non della capacità teorica della coppia.
Questo accorgimento previene desincronizzazioni quando il payload termina prima di saturare
l'ultima coppia di pixel disponibile.

\begin{lstlisting}[caption={Incremento dell'indice durante embedding}]
bits_to_embed = payload[bit_index : bit_index + capacity]
bit_index += len(bits_to_embed)
\end{lstlisting}

\subsection{Caratteristiche dell'Approccio}

PVD rappresenta un interessante compromesso tra la semplicità di LSB e la robustezza di DWT.
La natura adattiva dell'algoritmo, che modula la quantità di dati nascosti in base al
contenuto locale dell'immagine, produce una distribuzione delle modifiche più naturale e meno
rilevabile. Il PSNR risulta generalmente superiore a quello di LSB semplice, attestandosi
tra 45 e 55 dB. Tuttavia, la complessità implementativa è maggiore e la sincronizzazione tra
fasi di embedding ed estrazione deve essere gestita con precisione. L'algoritmo mostra
vulnerabilità a operazioni di ridimensionamento e ritaglio, che alterano la struttura delle
coppie di pixel su cui si basa il metodo.

\section{Confronto tra gli Algoritmi}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Caratteristica} & \textbf{LSB} & \textbf{DWT} & \textbf{PVD} \\ \hline
Capacità & Alta (3 bpp) & Media (0.5-1 bpp) & Alta (2-4 bpp) \\ \hline
PSNR medio & >50 dB & 35-45 dB & 45-55 dB \\ \hline
Velocità & Velocissimo & Lento & Medio \\ \hline
Robustezza & Bassa & Alta & Media \\ \hline
Complessità & Bassa & Alta & Media \\ \hline
Dominio & Spaziale & Frequenza & Spaziale \\ \hline
\end{tabular}
\caption{Confronto quantitativo tra gli algoritmi}
\end{table}
