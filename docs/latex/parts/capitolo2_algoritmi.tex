\chapter{Algoritmi Steganografici Implementati}

\section{LSB - Least Significant Bit}

\subsection{Principio di Funzionamento}

L'algoritmo LSB (Least Significant Bit) è uno dei metodi steganografici più diffusi grazie 
alla sua semplicità e alta capacità~\cite{cheddad2010lsb}. Il principio si basa sull'osservazione che modificare 
i bit meno significativi dei valori dei pixel produce cambiamenti impercettibili all'occhio 
umano.

In un'immagine RGB a 8 bit per canale, ogni pixel ha valori tra 0 e 255. Modificare l'ultimo 
bit (LSB) cambia il valore del pixel al massimo di ±1, una differenza invisibile.

\textbf{Esempio:}
\begin{itemize}
    \item Pixel originale: $11010110_2 = 214_{10}$
    \item Bit da nascondere: $1$
    \item Pixel modificato: $11010111_2 = 215_{10}$
\end{itemize}

\subsection{Implementazione}

L'implementazione nel progetto utilizza un approccio robusto con header strutturato:

\begin{lstlisting}[caption={Struttura del payload LSB}]
# Componenti del payload
magic_header = "1010101011110000"  # 16 bit - marker identificativo
msg_length = format(len(message), "032b")  # 32 bit - lunghezza
checksum = format(xor_checksum, "016b")  # 16 bit - verifica integrita
msg_binary = binary_convert(message)  # Messaggio codificato
terminator = "1111000011110000"  # 16 bit - fine messaggio

full_payload = magic_header + msg_length + checksum + msg_binary + terminator
\end{lstlisting}

Il processo di embedding scorre i pixel dell'immagine modificando l'LSB di ogni componente 
RGB:

\begin{lstlisting}[caption={Nascondimento LSB}]
for i in range(img.width):
    for j in range(img.height):
        for z in range(3):  # R, G, B
            if msg_list:
                bit = msg_list.pop(0)
                pixel = mat[i, j]
                color = int(pixel[z])
                color = set_last_bit(color, bit)
                mat = set_color_component(mat, i, j, color, z)
\end{lstlisting}

\subsection{Capacità e Prestazioni}

Per un'immagine di dimensione $W \times H$ pixel:
\begin{itemize}
    \item \textbf{Capacità teorica massima}: $W \times H \times 3$ bit (3 bit per pixel RGB)
    \item \textbf{Overhead header}: 80 bit fissi (magic + length + checksum + terminator)
    \item \textbf{Capacità effettiva}: $W \times H \times 3 - 80$ bit
\end{itemize}

\textbf{Esempio pratico:}
\begin{itemize}
    \item Immagine 800×600: 1,440,000 bit teorici = 180 KB
    \item Capacità effettiva: 179.99 KB
    \item Percentuale uso tipico: 0.1-5\% per messaggi normali
\end{itemize}

\subsection{Vantaggi e Limitazioni}

\textbf{Vantaggi:}
\begin{itemize}
    \item Implementazione semplice e veloce
    \item Alta capacità di embedding
    \item PSNR molto elevato (> 50 dB tipicamente)
    \item Modifiche completamente impercettibili
\end{itemize}

\textbf{Limitazioni:}
\begin{itemize}
    \item Vulnerabile a compressione JPEG (distrugge LSB)
    \item Facilmente rilevabile con analisi statistica
    \item Nessuna robustezza a modifiche dell'immagine
\end{itemize}

\section{DWT - Discrete Wavelet Transform}

\subsection{Principio di Funzionamento}

La DWT (Discrete Wavelet Transform) è una trasformazione matematica che decompone un segnale 
(o immagine) in coefficienti che rappresentano informazioni a diverse scale e posizioni. 
A differenza di LSB che opera nel dominio spaziale, DWT lavora nel dominio della frequenza.

La trasformata wavelet 2D decompone un'immagine in quattro sub-bande:
\begin{itemize}
    \item \textbf{cA (Approximation)}: Coefficienti di approssimazione - contiene informazioni 
          a bassa frequenza
    \item \textbf{cH (Horizontal)}: Dettagli orizzontali - bordi verticali
    \item \textbf{cV (Vertical)}: Dettagli verticali - bordi orizzontali  
    \item \textbf{cD (Diagonal)}: Dettagli diagonali - componenti ad alta frequenza
\end{itemize}

\subsection{Implementazione}

Il progetto utilizza la wavelet di Haar per la sua semplicità e efficienza~\cite{pywavelets2023}:

\begin{lstlisting}[caption={Decomposizione DWT}]
import pywt

# Applica DWT 2D al canale dell'immagine
coeffs = pywt.dwt2(channel_data, 'haar')
cA, (cH, cV, cD) = coeffs

# Nasconde nei coefficienti orizzontali (cH)
cH_flat = cH.flatten()
\end{lstlisting}

L'embedding avviene modificando i coefficienti in base al bit da nascondere:

\begin{lstlisting}[caption={Embedding DWT}]
# Modifica il coefficiente usando ALPHA
bit = int(payload_bit)
delta = ALPHA * 50  # Scala per robustezza

if bit == 1:
    cH_flat[i] += delta if cH_flat[i] > 0 else -delta
else:
    cH_flat[i] -= delta if cH_flat[i] > 0 else -delta
\end{lstlisting}

Il parametro \texttt{ALPHA} controlla la forza dell'embedding:
\begin{itemize}
    \item $\alpha = 0.05$: Qualità massima, capacità ridotta
    \item $\alpha = 0.1$: Bilanciato (default)
    \item $\alpha = 0.15$: Robustezza massima, più visibile
\end{itemize}

\subsection{Configurazioni Implementate}

Il sistema offre tre preset configurabili:

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Preset} & \textbf{ALPHA} & \textbf{Bande} & \textbf{Canali} \\ \hline
Qualità Massima & 0.05 & cH & R \\ \hline
Bilanciato & 0.10 & cH & R \\ \hline
Capacità Massima & 0.15 & cH, cV, cD & R, G, B \\ \hline
\end{tabular}
\caption{Configurazioni preset DWT}
\end{table}

\subsection{Vantaggi e Limitazioni}

\textbf{Vantaggi:}
\begin{itemize}
    \item Robustezza a compressione JPEG
    \item Resistenza a filtri e leggero rumore
    \item Più difficile da rilevare statisticamente
    \item Embedding nel dominio frequenza
\end{itemize}

\textbf{Limitazioni:}
\begin{itemize}
    \item Capacità inferiore rispetto a LSB
    \item Computazionalmente più costoso
    \item Richiede calibrazione parametri
    \item PSNR inferiore (35-45 dB tipicamente)
\end{itemize}

\section{PVD - Pixel Value Differencing}

\subsection{Principio di Funzionamento}

PVD (Pixel Value Differencing) è un algoritmo adattivo che sfrutta la differenza tra pixel 
adiacenti per nascondere dati. L'idea chiave è che modifiche maggiori sono meno percepibili 
in regioni con alti contrasti (bordi), mentre in regioni uniformi sono necessarie modifiche 
minori.

Il metodo divide l'immagine in coppie di pixel e calcola la loro differenza~\cite{wu2004pvd}:
$$d = |p_2 - p_1|$$

In base alla differenza, viene determinata la capacità di embedding usando range quantizzati.

\subsection{Range di Quantizzazione}

L'implementazione offre due profili di range:

\textbf{Profile Qualità (default):}
\begin{lstlisting}[caption={Range qualità PVD}]
RANGES_QUALITY = [
    (0, 7, 2),      # Diff 0-7: 2 bit
    (8, 15, 3),     # Diff 8-15: 3 bit
    (16, 31, 3),    # Diff 16-31: 3 bit
    (32, 63, 4),    # Diff 32-63: 4 bit
    (64, 127, 4),   # Diff 64-127: 4 bit
]
\end{lstlisting}

\textbf{Profile Capacità:}
\begin{lstlisting}[caption={Range capacità PVD}]
RANGES_CAPACITY = [
    (0, 7, 3),      # Diff 0-7: 3 bit
    (8, 15, 3),     # Diff 8-15: 3 bit
    (16, 31, 4),    # Diff 16-31: 4 bit
    (32, 63, 5),    # Diff 32-63: 5 bit
    (64, 127, 6),   # Diff 64-127: 6 bit
    (128, 255, 7),  # Diff 128-255: 7 bit
]
\end{lstlisting}

\subsection{Algoritmo di Embedding}

\begin{lstlisting}[caption={PVD embedding in una coppia di pixel}]
def embed_in_pair(pixel1, pixel2, bits):
    diff = pixel2 - pixel1
    lower, upper, capacity = get_range_capacity(diff)
    
    # Converte i bit in valore decimale
    decimal_value = int(bits[:capacity], 2)
    
    # Calcola la nuova differenza
    new_diff = lower + decimal_value
    new_diff = min(new_diff, upper)  # Clamp
    
    # Mantiene il segno
    if diff < 0:
        new_diff = -new_diff
    
    # Distribuzione della modifica
    m = abs(new_diff) - abs(diff)
    if diff % 2 == 0:
        new_pixel1 = pixel1 - m // 2
        new_pixel2 = pixel2 + m - m // 2
    else:
        new_pixel1 = pixel1 - (m + 1) // 2
        new_pixel2 = pixel2 + m - (m + 1) // 2
    
    # Clipping a [0, 255]
    return max(0, min(255, new_pixel1)), max(0, min(255, new_pixel2))
\end{lstlisting}

\subsection{Parametri Configurabili}

\begin{itemize}
    \item \textbf{RANGES}: Profilo di quantizzazione (qualità o capacità)
    \item \textbf{PAIR\_STEP}: Spaziatura tra coppie di pixel (1-4)
          \begin{itemize}
              \item Step=1: massima capacità, tutti i pixel
              \item Step>1: capacità ridotta, più distribuito
          \end{itemize}
    \item \textbf{CHANNELS}: Canali RGB da utilizzare ([0], [0,1,2], ecc.)
\end{itemize}

\subsection{Vantaggi e Limitazioni}

\textbf{Vantaggi:}
\begin{itemize}
    \item Embedding adattivo al contenuto
    \item Buon compromesso capacità/qualità
    \item PSNR superiore a LSB semplice
    \item Distribuzione naturale delle modifiche
\end{itemize}

\textbf{Limitazioni:}
\begin{itemize}
    \item Più complesso di LSB
    \item Vulnerabile a ritaglio e ridimensionamento
    \item Richiede sincronizzazione precisa
    \item Sensibile a modifiche dei pixel di bordo
\end{itemize}

\section{Confronto tra gli Algoritmi}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Caratteristica} & \textbf{LSB} & \textbf{DWT} & \textbf{PVD} \\ \hline
Capacità & Alta (3 bpp) & Media (0.5-1 bpp) & Alta (2-4 bpp) \\ \hline
PSNR medio & >50 dB & 35-45 dB & 45-55 dB \\ \hline
Velocità & Velocissimo & Lento & Medio \\ \hline
Robustezza & Bassa & Alta & Media \\ \hline
Complessità & Bassa & Alta & Media \\ \hline
Dominio & Spaziale & Frequenza & Spaziale \\ \hline
\end{tabular}
\caption{Confronto quantitativo tra gli algoritmi}
\end{table}
