\chapter{Implementazione}

\section{Tecnologie Utilizzate}

\subsection{Stack Tecnologico}

Il progetto è sviluppato interamente in Python 3.12 (ma è retrocompatibile con versioni precedenti dalla 3.9 in poi) utilizzando le seguenti librerie~\cite{streamlit2023, numpy2020, van2014scikit}:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Libreria} & \textbf{Versione} & \textbf{Scopo} \\ \hline
Streamlit & >=1.20.0 & Framework web per l'interfaccia utente \\ \hline
NumPy & >=1.24.0 & Operazioni matriciali e calcoli numerici \\ \hline
Pillow (PIL) & >=9.5.0 & Manipolazione e I/O immagini \\ \hline
PyWavelets & >=1.4.0 & Trasformata wavelet per DWT \\ \hline
scikit-image & >=0.20.0 & Metriche di qualita (SSIM) \\ \hline
\end{tabular}
\caption{Dipendenze principali del progetto}
\end{table}

\subsection{Gestione Dipendenze con uv}

Il progetto utilizza \texttt{uv} come package manager per gestione rapida e affidabile delle 
dipendenze:

\begin{lstlisting}[caption={pyproject.toml - configurazione dipendenze}, language=bash]
[project]
name = "steganography-webapp"
version = "1.0.0"
requires-python = ">=3.9"

dependencies = [
    "streamlit>=1.20.0",
    "numpy>=1.24.0",
    "Pillow>=9.5.0",
    "PyWavelets>=1.4.0",
    "scikit-image>=0.20.0",
]

[project.optional-dependencies]
dev = [
    "black>=23.0.0",
    "isort>=5.12.0",
]

[tool.uv]
dev-dependencies = [
    "black>=23.0.0",
    "isort>=5.12.0",
]
\end{lstlisting}

\section{Implementazione degli Algoritmi}

\subsection{Sistema di Conversione Binaria}

Tutti gli algoritmi si basano su funzioni di conversione tra testo e binario:

\begin{lstlisting}[caption={Conversione testo-binario}]
def binary_convert(s: str) -> str:
    """Converte una stringa in rappresentazione binaria"""
    binary = "".join(format(ord(char), "08b") for char in s)
    return binary

def binary_convert_back(s: str) -> str:
    """Riconverte binario in stringa"""
    chars = [s[i:i+8] for i in range(0, len(s), 8)]
    text = "".join(chr(int(char, 2)) for char in chars)
    return text
\end{lstlisting}

\subsection{Manipolazione Bit LSB}

Operazioni fondamentali per l'algoritmo LSB:

\begin{lstlisting}[caption={Operazioni bit-level}]
def set_last_bit(value: int, bit: str) -> int:
    """Imposta l'ultimo bit di un valore"""
    if bit == "1":
        return value | 1  # OR bit-wise per settare a 1
    else:
        return value & ~1  # AND con NOT per settare a 0

def get_last_bit(value: int) -> str:
    """Estrae l'ultimo bit di un valore"""
    return str(value & 1)

def set_color_component(mat, x: int, y: int, value: int, component: int):
    """Modifica una componente RGB di un pixel"""
    pixel = list(mat[x, y])
    pixel[component] = value
    mat[x, y] = tuple(pixel)
    return mat
\end{lstlisting}

\subsection{Sistema di Backup Parametri}

Implementazione del salvataggio automatico dei parametri per il recupero:

\begin{lstlisting}[caption={Sistema backup JSON}]
import json
import os
from pathlib import Path

class ParameterBackup:
    @staticmethod
    def save_backup_data(data_type, params, filepath=None):
        """Salva parametri in file JSON"""
        if filepath is None:
            filepath = f"backup_{data_type}_{int(time.time())}.json"
        
        backup_data = {
            "data_type": data_type,
            "timestamp": time.time(),
            "parameters": params,
            "version": "1.0"
        }
        
        with open(filepath, "w") as f:
            json.dump(backup_data, f, indent=2)
        
        return filepath
    
    @staticmethod
    def load_backup_data(filepath):
        """Carica parametri da file JSON"""
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"File backup non trovato: {filepath}")
        
        with open(filepath, "r") as f:
            backup_data = json.load(f)
        
        return backup_data["parameters"]
\end{lstlisting}

\subsection{Calcolo Metriche di Qualità}

Implementazione PSNR e SSIM usando direttamente le librerie scikit-image:

\begin{lstlisting}[caption={Metriche di qualità}]
import numpy as np
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim

class QualityMetrics:
    @staticmethod
    def calculate_metrics(original_img: Image.Image, 
                         modified_img: Image.Image) -> dict:
        """Calcola SSIM e PSNR tra immagine originale e modificata"""
        # Converte in RGB se necessario
        if original_img.mode != "RGB":
            original_img = original_img.convert("RGB")
        if modified_img.mode != "RGB":
            modified_img = modified_img.convert("RGB")
        
        # Converte in array numpy
        original_array = np.array(original_img)
        modified_array = np.array(modified_img)
        
        # Calcola SSIM (per immagini multichannel)
        ssim_value = ssim(
            original_array,
            modified_array,
            channel_axis=2,  # RGB ha 3 canali
            data_range=255,  # Range dei valori dei pixel (0-255)
        )
        
        # Calcola PSNR usando direttamente la libreria
        if np.array_equal(original_array, modified_array):
            psnr_value = np.inf
        else:
            psnr_value = psnr(original_array, modified_array, 
                            data_range=255)
        
        return {"ssim": ssim_value, "psnr": psnr_value}
    
    @staticmethod
    def format_metrics(metrics: dict) -> str:
        """Formatta le metriche in una stringa leggibile"""
        ssim_val = metrics["ssim"]
        psnr_val = metrics["psnr"]
        
        # Interpreta qualita SSIM
        if ssim_val >= 0.99:
            ssim_quality = "Eccellente"
        elif ssim_val >= 0.95:
            ssim_quality = "Ottima"
        else:
            ssim_quality = "Buona"
        
        # Interpreta qualita PSNR
        if np.isinf(psnr_val):
            psnr_str = "inf"
            psnr_quality = "Perfetto"
        elif psnr_val >= 40:
            psnr_str = f"{psnr_val:.2f}"
            psnr_quality = "Ottima"
        else:
            psnr_str = f"{psnr_val:.2f}"
            psnr_quality = "Buona"
        
        return (f"SSIM: {ssim_val:.4f} ({ssim_quality}) | "
                f"PSNR: {psnr_str} dB ({psnr_quality})")
\end{lstlisting}

\section{Ottimizzazioni Implementate}

\subsection{Pre-validazione Capacita}

Prima di iniziare l'embedding, il sistema verifica la capacita disponibile:

\begin{lstlisting}[caption={Pre-validazione per evitare computazioni inutili}]
# Calcola capacita prima dell'embedding
required_bits = len(message) * 8 + header_size
available_bits = img.width * img.height * 3

if required_bits > available_bits:
    # Fallimento immediato senza iniziare l'embedding
    raise ValueError("Capacita insufficiente")

# Mostra percentuale utilizzo previsto
usage = (required_bits / available_bits) * 100
st.info(f"Utilizzo previsto: {usage:.2f}%")
\end{lstlisting}

\section{Gestione File Temporanei}

Sistema robusto per gestire file temporanei durante le operazioni:

\begin{lstlisting}[caption={Gestione sicura file temporanei}]
import tempfile
import os

def save_uploaded_file(uploaded_file):
    """Salva file caricato in directory temporanea"""
    temp_dir = tempfile.gettempdir()
    temp_path = os.path.join(temp_dir, uploaded_file.name)
    
    with open(temp_path, "wb") as f:
        f.write(uploaded_file.getvalue())
    
    return temp_path

def cleanup_temp_file(filepath):
    """Rimuove file temporaneo se esiste"""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception as e:
        # Log warning ma non bloccare l'esecuzione
        print(f"Warning: impossibile rimuovere {filepath}: {e}")
\end{lstlisting}

\section{Testing e Quality Assurance}

\subsection{Code Formatting}

Il progetto utilizza Black e isort per mantenere coerenza del codice:

\begin{lstlisting}[caption={Configurazione formattazione}, language=bash]
[tool.black]
line-length = 88
target-version = ["py311"]

[tool.isort]
profile = "black"
line_length = 88
\end{lstlisting}

\subsection{Continuous Integration}

Pipeline CI/CD con GitHub Actions:

\begin{lstlisting}[caption={CI workflow con uv}, language=bash]
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true
      
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      
      - name: Install dependencies
        run: uv sync --all-extras
      
      - name: Check import sorting
        run: uv run isort src/ config/ --check-only
      
      - name: Check code formatting
        run: uv run black src/ config/ --check
\end{lstlisting}

\section{Deploy su Streamlit Cloud}

L'applicazione è deployata su Streamlit Cloud con configurazione automatica:

\begin{itemize}
    \item \textbf{uv.lock}: Rilevato automaticamente da Streamlit Cloud
    \item \textbf{.python-version}: Specifica Python 3.12
    \item \textbf{pyproject.toml}: Contiene tutte le dipendenze
\end{itemize}

Il deploy è completamente automatizzato: ogni push su \texttt{main} triggera un redeploy.
