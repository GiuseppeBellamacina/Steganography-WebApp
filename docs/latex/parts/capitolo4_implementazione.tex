\chapter{Implementazione}

\section{Tecnologie Utilizzate}

\subsection{Stack Tecnologico}

Il progetto è sviluppato interamente in Python 3.12 (ma è retrocompatibile con versioni precedenti dalla 3.9 in poi) utilizzando le seguenti librerie~\cite{streamlit2023, numpy2020, van2014scikit}:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Libreria} & \textbf{Versione} & \textbf{Scopo} \\ \hline
Streamlit & >=1.20.0 & Framework web per l'interfaccia utente \\ \hline
NumPy & >=1.24.0 & Operazioni matriciali e calcoli numerici \\ \hline
Pillow (PIL) & >=9.5.0 & Manipolazione e I/O immagini \\ \hline
PyWavelets & >=1.4.0 & Trasformata wavelet per DWT \\ \hline
scikit-image & >=0.20.0 & Metriche di qualita (SSIM) \\ \hline
\end{tabular}
\caption{Dipendenze principali del progetto}
\end{table}

\subsection{Gestione Dipendenze con uv}

Il progetto utilizza \texttt{uv} come package manager per gestione rapida e affidabile delle 
dipendenze:

\begin{lstlisting}[caption={pyproject.toml - configurazione dipendenze}, language=bash]
[project]
name = "steganography-webapp"
version = "1.0.0"
requires-python = ">=3.9"

dependencies = [
    "streamlit>=1.20.0",
    "numpy>=1.24.0",
    "Pillow>=9.5.0",
    "PyWavelets>=1.4.0",
    "scikit-image>=0.20.0",
]

[project.optional-dependencies]
dev = [
    "black>=23.0.0",
    "isort>=5.12.0",
]

[tool.uv]
dev-dependencies = [
    "black>=23.0.0",
    "isort>=5.12.0",
]
\end{lstlisting}

\section{Implementazione degli Algoritmi}

\subsection{Sistema di Conversione Binaria}

Tutti gli algoritmi si basano su funzioni di conversione tra testo e binario:

\begin{lstlisting}[caption={Conversione testo-binario}]
def binary_convert(s: str) -> str:
    """Converte una stringa in rappresentazione binaria"""
    binary = "".join(format(ord(char), "08b") for char in s)
    return binary

def binary_convert_back(s: str) -> str:
    """Riconverte binario in stringa"""
    chars = [s[i:i+8] for i in range(0, len(s), 8)]
    text = "".join(chr(int(char, 2)) for char in chars)
    return text
\end{lstlisting}

\subsection{Manipolazione Bit LSB}

Operazioni fondamentali per l'algoritmo LSB:

\begin{lstlisting}[caption={Operazioni bit-level}]
def set_last_bit(value: int, bit: str) -> int:
    """Imposta l'ultimo bit di un valore"""
    if bit == "1":
        return value | 1  # OR bit-wise per settare a 1
    else:
        return value & ~1  # AND con NOT per settare a 0

def get_last_bit(value: int) -> str:
    """Estrae l'ultimo bit di un valore"""
    return str(value & 1)

def set_color_component(mat, x: int, y: int, value: int, component: int):
    """Modifica una componente RGB di un pixel"""
    pixel = list(mat[x, y])
    pixel[component] = value
    mat[x, y] = tuple(pixel)
    return mat
\end{lstlisting}

\subsection{Sistema di Backup Parametri}

Implementazione del salvataggio automatico dei parametri per il recupero:

\begin{lstlisting}[caption={Sistema backup JSON}]
import json
import os
from pathlib import Path

class ParameterBackup:
    @staticmethod
    def save_backup_data(data_type, params, filepath=None):
        """Salva parametri in file JSON"""
        if filepath is None:
            filepath = f"backup_{data_type}_{int(time.time())}.json"
        
        backup_data = {
            "data_type": data_type,
            "timestamp": time.time(),
            "parameters": params,
            "version": "1.0"
        }
        
        with open(filepath, "w") as f:
            json.dump(backup_data, f, indent=2)
        
        return filepath
    
    @staticmethod
    def load_backup_data(filepath):
        """Carica parametri da file JSON"""
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"File backup non trovato: {filepath}")
        
        with open(filepath, "r") as f:
            backup_data = json.load(f)
        
        return backup_data["parameters"]
\end{lstlisting}

\subsection{Calcolo Metriche di Qualità}

Implementazione PSNR e SSIM usando direttamente le librerie scikit-image:

\begin{lstlisting}[caption={Metriche di qualità}]
import numpy as np
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim

class QualityMetrics:
    @staticmethod
    def calculate_metrics(original_img: Image.Image, 
                         modified_img: Image.Image) -> dict:
        """Calcola SSIM e PSNR tra immagine originale e modificata"""
        # Converte in RGB se necessario
        if original_img.mode != "RGB":
            original_img = original_img.convert("RGB")
        if modified_img.mode != "RGB":
            modified_img = modified_img.convert("RGB")
        
        # Converte in array numpy
        original_array = np.array(original_img)
        modified_array = np.array(modified_img)
        
        # Calcola SSIM (per immagini multichannel)
        ssim_value = ssim(
            original_array,
            modified_array,
            channel_axis=2,  # RGB ha 3 canali
            data_range=255,  # Range dei valori dei pixel (0-255)
        )
        
        # Calcola PSNR usando direttamente la libreria
        if np.array_equal(original_array, modified_array):
            psnr_value = np.inf
        else:
            psnr_value = psnr(original_array, modified_array, 
                            data_range=255)
        
        return {"ssim": ssim_value, "psnr": psnr_value}
    
    @staticmethod
    def format_metrics(metrics: dict) -> str:
        """Formatta le metriche in una stringa leggibile"""
        ssim_val = metrics["ssim"]
        psnr_val = metrics["psnr"]
        
        # Interpreta qualita SSIM
        if ssim_val >= 0.99:
            ssim_quality = "Eccellente"
        elif ssim_val >= 0.95:
            ssim_quality = "Ottima"
        else:
            ssim_quality = "Buona"
        
        # Interpreta qualita PSNR
        if np.isinf(psnr_val):
            psnr_str = "inf"
            psnr_quality = "Perfetto"
        elif psnr_val >= 40:
            psnr_str = f"{psnr_val:.2f}"
            psnr_quality = "Ottima"
        else:
            psnr_str = f"{psnr_val:.2f}"
            psnr_quality = "Buona"
        
        return (f"SSIM: {ssim_val:.4f} ({ssim_quality}) | "
                f"PSNR: {psnr_str} dB ({psnr_quality})")
\end{lstlisting}

\section{Ottimizzazioni Implementate}

\subsection{Pre-validazione Capacita}

Prima di iniziare l'embedding, il sistema verifica la capacita disponibile:

\begin{lstlisting}[caption={Pre-validazione per evitare computazioni inutili}]
# Calcola capacita prima dell'embedding
required_bits = len(message) * 8 + header_size
available_bits = img.width * img.height * 3

if required_bits > available_bits:
    # Fallimento immediato senza iniziare l'embedding
    raise ValueError("Capacita insufficiente")

# Mostra percentuale utilizzo previsto
usage = (required_bits / available_bits) * 100
st.info(f"Utilizzo previsto: {usage:.2f}%")
\end{lstlisting}

\section{Gestione File Temporanei}

Sistema robusto per gestire file temporanei durante le operazioni:

\begin{lstlisting}[caption={Gestione sicura file temporanei}]
import tempfile
import os

def save_uploaded_file(uploaded_file):
    """Salva file caricato in directory temporanea"""
    temp_dir = tempfile.gettempdir()
    temp_path = os.path.join(temp_dir, uploaded_file.name)
    
    with open(temp_path, "wb") as f:
        f.write(uploaded_file.getvalue())
    
    return temp_path

def cleanup_temp_file(filepath):
    """Rimuove file temporaneo se esiste"""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception as e:
        # Log warning ma non bloccare l'esecuzione
        print(f"Warning: impossibile rimuovere {filepath}: {e}")
\end{lstlisting}

\section{Testing e Quality Assurance}

\subsection{Code Formatting}

Il progetto utilizza Black e isort per mantenere coerenza del codice:

\begin{lstlisting}[caption={Configurazione formattazione}, language=bash]
[tool.black]
line-length = 88
target-version = ["py311"]

[tool.isort]
profile = "black"
line_length = 88
\end{lstlisting}

\subsection{Continuous Integration}

Pipeline CI/CD con GitHub Actions:

\begin{lstlisting}[caption={CI workflow con uv}, language=bash]
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true
      
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      
      - name: Install dependencies
        run: uv sync --all-extras
      
      - name: Check import sorting
        run: uv run isort src/ config/ --check-only
      
      - name: Check code formatting
        run: uv run black src/ config/ --check
\end{lstlisting}

\section{Deploy su Streamlit Cloud}

L'applicazione è deployata su Streamlit Cloud con configurazione automatica:

\begin{itemize}
    \item \textbf{uv.lock}: Rilevato automaticamente da Streamlit Cloud
    \item \textbf{.python-version}: Specifica Python 3.12
    \item \textbf{pyproject.toml}: Contiene tutte le dipendenze
\end{itemize}

Il deploy è completamente automatizzato: ogni push su \texttt{main} triggera un redeploy.
\section{Test Sperimentali LSB - Occultamento Immagini}

In questa sezione presentiamo una serie di test sperimentali dell'algoritmo LSB per l'occultamento di immagini, variando i parametri LSB e MSB per analizzare il trade-off tra qualità visiva e capacità di occultamento.

\subsection{Setup Sperimentale}

Per tutti i test sono state utilizzate le seguenti immagini:
\begin{itemize}
    \item \textbf{Immagine Host}: \texttt{host.jpg} - immagine carrier di dimensioni maggiori
    \item \textbf{Immagine Segreta}: \texttt{occulted.jpg} - immagine da nascondere (720×1280 pixel)
\end{itemize}

\subsection{Test 1: Configurazione Bilanciata (LSB=4, MSB=4)}

Questa configurazione rappresenta un buon compromesso tra qualità visiva e capacità di occultamento.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
LSB & 4 bit \\ \hline
MSB & 4 bit \\ \hline
DIV & 3.38 (automatico) \\ \hline
Pixel utilizzati & 29.63\% \\ \hline
SSIM & 0.8563 (Eccellente) \\ \hline
PSNR & 35.84 dB (Buona) \\ \hline
\end{tabular}
\caption{Parametri e metriche per configurazione bilanciata}
\end{table}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/lsb_4-msb_4.png}
        \caption{Immagine stego con LSB=4, MSB=4}
        \label{fig:lsb_4_4_stego}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/recovered_lsb_4-msb_4.png}
        \caption{Immagine recuperata da LSB=4, MSB=4}
        \label{fig:lsb_4_4_recovered}
    \end{minipage}
\end{figure}

\textbf{Analisi}: Con LSB=4 e MSB=4 si ottiene un eccellente SSIM di 0.8563, indicando che l'immagine stego è quasi indistinguibile dall'originale. Il recupero dell'immagine segreta è preciso, preservando 4 bit per canale.

\subsection{Test 2: Alta Qualità (LSB=1, MSB=1)}

Configurazione che privilegia la massima qualità dell'immagine stego a discapito della fedeltà dell'immagine recuperata.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
LSB & 1 bit \\ \hline
MSB & 1 bit \\ \hline
DIV & 3.38 (automatico) \\ \hline
Pixel utilizzati & 29.63\% \\ \hline
SSIM & 0.9981 (Eccellente) \\ \hline
PSNR & 56.60 dB (Eccellente) \\ \hline
\end{tabular}
\caption{Parametri e metriche per configurazione alta qualità}
\end{table}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/lsb_1-msb_1.png}
        \caption{Immagine stego con LSB=1, MSB=1}
        \label{fig:lsb_1_1_stego}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/recovered_lsb_1-msb_1.png}
        \caption{Immagine recuperata da LSB=1, MSB=1}
        \label{fig:lsb_1_1_recovered}
    \end{minipage}
\end{figure}

\textbf{Analisi}: Con LSB=1 e MSB=1 si ottiene un SSIM quasi perfetto (0.9981) e un PSNR eccellente di 56.60 dB. L'immagine stego è praticamente identica all'originale. Tuttavia, l'immagine recuperata preserva solo 1 bit per canale, risultando in una qualità visiva degradata ma ancora riconoscibile.

\subsection{Test 3: Alta Capacità (LSB=6, MSB=2)}

Configurazione che massimizza la capacità di occultamento utilizzando più bit dell'immagine host.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
LSB & 6 bit \\ \hline
MSB & 2 bit \\ \hline
DIV & 10.12 (automatico) \\ \hline
Pixel utilizzati & 9.88\% \\ \hline
SSIM & 0.5601 (Accettabile) \\ \hline
PSNR & 27.07 dB (Accettabile) \\ \hline
\end{tabular}
\caption{Parametri e metriche per configurazione alta capacità}
\end{table}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/capacita-lsb_6-msb_2.png}
        \caption{Immagine stego con LSB=6, MSB=2}
        \label{fig:lsb_6_2_stego}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/recovered_lsb_6-msb_2.png}
        \caption{Immagine recuperata da LSB=6, MSB=2}
        \label{fig:lsb_6_2_recovered}
    \end{minipage}
\end{figure}

\textbf{Analisi}: Modificando 6 bit per pixel si riduce significativamente l'utilizzo dell'immagine host (solo 9.88\% dei pixel), ma a costo di una qualità visiva ridotta (SSIM=0.5601). L'immagine recuperata preserva solo 2 bit per canale.

\subsection{Test 4: Massima Capacità Estrema (LSB=7, MSB=8)}

Test estremo che modifica quasi tutti i bit dell'immagine host per preservare l'intera profondità colore dell'immagine segreta.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
LSB & 7 bit \\ \hline
MSB & 8 bit (tutti) \\ \hline
DIV & 2.95 (automatico) \\ \hline
Pixel utilizzati & 33.86\% \\ \hline
SSIM & 0.1008 (Scarsa) \\ \hline
PSNR & 18.03 dB (Scarsa) \\ \hline
\end{tabular}
\caption{Parametri e metriche per configurazione estrema}
\end{table}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/lsb_7-msb_8.png}
        \caption{Immagine stego con LSB=7, MSB=8}
        \label{fig:lsb_7_8_stego}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{assets/lsb/recovered_lsb_7-msb_8.png}
        \caption{Immagine recuperata da LSB=7, MSB=8 (qualit\`a perfetta)}
        \label{fig:lsb_7_8_recovered}
    \end{minipage}
\end{figure}

\textbf{Analisi}: Con LSB=7 e MSB=8 si ottiene un recupero perfetto dell'immagine segreta (tutti gli 8 bit preservati), ma l'immagine stego presenta distorsioni evidenti (SSIM=0.1008, PSNR=18.03 dB). Questa configurazione è inadatta per applicazioni steganografiche reali.

\subsection{Test 5: Modalità Automatica (LSB=auto, MSB=8)}

Test della modalità automatica che calcola il valore ottimale di LSB in base alle dimensioni delle immagini.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
LSB & 3 bit (calcolato automaticamente) \\ \hline
MSB & 8 bit \\ \hline
DIV & 1.27 (automatico) \\ \hline
Pixel utilizzati & 79.01\% \\ \hline
SSIM & 0.9000 (Eccellente) \\ \hline
PSNR & 38.39 dB (Buona) \\ \hline
\end{tabular}
\caption{Parametri e metriche per modalità automatica}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{assets/lsb/lsb_auto-msb_auto.png}
    \caption{Immagine stego con modalità automatica (LSB=3, MSB=8)}
    \label{fig:lsb_auto_stego}
\end{figure}

\textbf{Analisi}: La modalità automatica ha calcolato LSB=3 come valore ottimale per nascondere l'intera immagine segreta (MSB=8) mantenendo un'eccellente qualità visiva (SSIM=0.9000, PSNR=38.39 dB). L'utilizzo dei pixel è elevato (79.01\%), indicando un'efficiente distribuzione dei dati.

\subsection{Conclusioni sui Test LSB}

I test dimostrano chiaramente il trade-off tra qualità dell'immagine stego e fedeltà dell'immagine recuperata:

\begin{itemize}
    \item \textbf{LSB=1, MSB=1}: Ottima invisibilità (SSIM=0.998), immagine recuperata degradata
    \item \textbf{LSB=4, MSB=4}: Configurazione bilanciata raccomandata (SSIM=0.856)
    \item \textbf{LSB=6, MSB=2}: Basso utilizzo pixel (9.88\%), qualità accettabile
    \item \textbf{LSB=7, MSB=8}: Recupero perfetto ma distorsioni visibili
    \item \textbf{Modalità automatica}: Calcolo intelligente per ottimizzare capacità/qualità
\end{itemize}

La scelta dei parametri dipende dal caso d'uso: per steganografia che richiede invisibilit\`a, configurazioni con LSB$\leq$4 sono preferibili. Per archiviazione con compressione visiva accettabile, configurazioni con MSB$\geq$6 preservano meglio l'immagine segreta.

\section{Test Sperimentali LSB - Occultamento File Binari}

In questa sezione presentiamo test sperimentali dell'algoritmo LSB per l'occultamento di file binari, analizzando l'impatto del parametro N (numero di bit modificati per pixel) sulla qualit\`a visiva dell'immagine stego.

\subsection{Setup Sperimentale}

Per tutti i test \`e stato utilizzato:
\begin{itemize}
    \item \textbf{Immagine Host}: \texttt{host.jpg} - immagine carrier
    \item \textbf{File Binario}: File di test (dimensione variabile)
    \item \textbf{DIV}: Calcolato automaticamente (tranne Test 5)
\end{itemize}

\subsection{Test 1: Configurazione Alta Qualit\`a (N=2)}

Configurazione che privilegia la massima qualit\`a visiva modificando solo 2 bit per pixel.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
N (bit per pixel) & 2 bit \\ \hline
DIV & 1.16 (automatico) \\ \hline
Pixel utilizzati & 85.98\% \\ \hline
SSIM & 0.9719 (Eccellente) \\ \hline
PSNR & 44.85 dB (Eccellente) \\ \hline
\end{tabular}
\caption{Parametri e metriche per N=2}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{assets/lsb/n2.png}
    \caption{Immagine stego con N=2 - massima qualit\`a visiva}
    \label{fig:n2_stego}
\end{figure}

\textbf{Analisi}: Con N=2 si ottiene un SSIM quasi perfetto (0.9719) e PSNR eccellente (44.85 dB). L'immagine \`e praticamente identica all'originale. L'elevato utilizzo dei pixel (85.98\%) indica che quasi tutta l'immagine viene impiegata per nascondere i dati.

\subsection{Test 2: Configurazione Bilanciata (N=4)}

Configurazione che offre un buon compromesso tra capacit\`a e qualit\`a visiva.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
N (bit per pixel) & 4 bit \\ \hline
DIV & 2.33 (automatico) \\ \hline
Pixel utilizzati & 42.99\% \\ \hline
SSIM & 0.8194 (Eccellente) \\ \hline
PSNR & 35.74 dB (Buona) \\ \hline
\end{tabular}
\caption{Parametri e metriche per N=4}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{assets/lsb/n4.png}
    \caption{Immagine stego con N=4 - configurazione bilanciata}
    \label{fig:n4_stego}
\end{figure}

\textbf{Analisi}: N=4 rappresenta la configurazione raccomandata per la maggior parte degli utilizzi. Mantiene un'eccellente qualit\`a visiva (SSIM=0.8194) con un utilizzo efficiente dei pixel (42.99\%).

\subsection{Test 3: Configurazione Alta Capacit\`a (N=6)}

Configurazione che massimizza la capacit\`a di occultamento modificando 6 bit per pixel.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
N (bit per pixel) & 6 bit \\ \hline
DIV & 3.49 (automatico) \\ \hline
Pixel utilizzati & 28.66\% \\ \hline
SSIM & 0.3167 (Accettabile) \\ \hline
PSNR & 24.57 dB (Accettabile) \\ \hline
\end{tabular}
\caption{Parametri e metriche per N=6}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{assets/lsb/n6.png}
    \caption{Immagine stego con N=6 - alta capacit\`a}
    \label{fig:n6_stego}
\end{figure}

\textbf{Analisi}: Con N=6 l'utilizzo dei pixel scende al 28.66\%, permettendo di nascondere pi\`u dati in meno spazio. Tuttavia, la qualit\`a visiva \`e ridotta (SSIM=0.3167), con distorsioni visibili ma accettabili per alcuni scenari.

\subsection{Test 4: Configurazione Estrema con DIV Automatico (N=8)}

Test estremo che modifica tutti gli 8 bit per pixel con DIV calcolato automaticamente.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
N (bit per pixel) & 8 bit (tutti) \\ \hline
DIV & 4.65 (automatico) \\ \hline
Pixel utilizzati & 21.50\% \\ \hline
SSIM & 0.0592 (Scarsa) \\ \hline
PSNR & 12.94 dB (Scarsa) \\ \hline
\end{tabular}
\caption{Parametri e metriche per N=8 con DIV automatico}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{assets/lsb/n8.png}
    \caption{Immagine stego con N=8, DIV automatico - distorsioni evidenti}
    \label{fig:n8_auto_stego}
\end{figure}

\textbf{Analisi}: Modificando tutti gli 8 bit con DIV automatico si ottiene la massima capacit\`a (solo 21.50\% dei pixel utilizzati), ma l'immagine presenta distorsioni molto evidenti (SSIM=0.0592, PSNR=12.94 dB). Inadatto per steganografia.

\subsection{Test 5: Configurazione Estrema con DIV=1 (N=8)}

Test estremo che modifica tutti gli 8 bit per pixel con DIV fissato a 1 (nessuna distribuzione).

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Parametro} & \textbf{Valore} \\ \hline
N (bit per pixel) & 8 bit (tutti) \\ \hline
DIV & 1.00 (manuale) \\ \hline
Pixel utilizzati & 21.50\% \\ \hline
SSIM & 0.7859 (Buona) \\ \hline
PSNR & 13.75 dB (Scarsa) \\ \hline
\end{tabular}
\caption{Parametri e metriche per N=8 con DIV=1}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{assets/lsb/n8-div1.png}
    \caption{Immagine stego con N=8, DIV=1 - concentrazione visibile}
    \label{fig:n8_div1_stego}
\end{figure}

\textbf{Analisi}: Con DIV=1 i dati vengono scritti consecutivamente senza distribuzione. Curiosamente, l'SSIM migliora rispetto al DIV automatico (0.7859 vs 0.0592), ma il PSNR rimane basso (13.75 dB). La concentrazione dei dati \`e visibile nell'immagine, creando pattern riconoscibili.

\subsection{Conclusioni sui Test LSB Binary}

I test dimostrano l'impatto del parametro N sulla qualit\`a dell'immagine stego:

\begin{itemize}
    \item \textbf{N=2}: Massima qualit\`a (SSIM=0.972), alto utilizzo pixel (86\%)
    \item \textbf{N=4}: Configurazione bilanciata raccomandata (SSIM=0.819)
    \item \textbf{N=6}: Alta capacit\`a, qualit\`a accettabile (SSIM=0.317)
    \item \textbf{N=8, DIV auto}: Massima capacit\`a, qualit\`a scarsa (SSIM=0.059)
    \item \textbf{N=8, DIV=1}: Pattern visibili, inadatto per steganografia
\end{itemize}

Il parametro DIV influenza la distribuzione dei dati: valori automatici distribuiscono uniformemente i dati nell'immagine, mentre DIV=1 concentra i dati creando artefatti visibili. Per applicazioni steganografiche, N$\leq$4 con DIV automatico offre il miglior compromesso invisibilit\`a/capacit\`a.